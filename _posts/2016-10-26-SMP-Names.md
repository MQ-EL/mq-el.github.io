---
layout: post
category : learning
tagline: "scala meta-programming"
tags : [scala, metaprogramming]
---
{% include JB/setup %}

### Names 

Names本质上是封装了一个String。封装的其中一个目的是区分TermName和TypeName。想一想Symbol，也有类似区分。

```scala
    trait Names {
        ...
        type Name >: Null <: AnyRef with NameApi
        
        type TypeName >: Null <: TypeNameApi with Name
        
        type TermName >: Null <: TermNameApi with Name
        
        trait TypeNameApi
        
        trait TermNameApi
        
        abstract class NameApi {...}
        
        ...
    }
```

如果跟Symbol风格类似的化，NameApi可以定义成trait，然后TypeNameApi和TermNameApi继承它。
通过git blame，在commit 3293d60发现添加的，应该是遗漏了。scala的弹性同时意味着表现复杂性。

### Name提供的能力

```scala
    abstract class NameApi {
        def isTermName: Boolean
        def isTypeName: Boolean
        def toTermName: TermName
        def toTypeName: TypeName
        
        def decodedName: Name //Replace $op_name by corresponding operator symbol.
        def encodedName: Name //Replace operator symbols by corresponding $op_name symbol.
    }
```

* 对`toXXX`,TermName可以转成TypeName，反之亦然。对于实现，两种Name都是Internal的，
就是都是缓存起来的，存在termHashtable和typeHashtable里，大小是0x8000。每个Name都是一个单向链表。
也就意味着Types和terms是有独立的命名空间的，例如同一个单例A，存在TermName("A")和TypeName("A")。
实现主要思路：分配0x8000大小的数组Array[char]，所有TermName和TypeName里的String都放在里面，避免了二次重复。
为了TermName和TypeName提升查找效率，分别声明的了termHashtable：Array[char]和TypeHashtable[char]，下标是hash值（以首中尾字符计算而来）。
呵呵，那么健冲突怎么搞，因此无论是TermName还是TypeName，都有保有下个Name的引用。

* [biased lock](https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot), 简版可以参考[此处](http://arturmkrtchyan.com/jvm-biased-locking)。
Biased locking目的是在大部分时间没有竞争的多线程环境中提供比CAS更高的效率。对于TermName和TypeName，多线程访问的竞争点是创建vs创建，及查找vs创建，
并且大部分用例是单线程环境，为了保证线程安全及单线程访问效率，biased比较合适。文档中说了一点，由于threadId放在对象头中（保存biased thread），占用了对象自己的
identity hash code，但是identity hash code优先级高，会撤回bias，这个比较头疼啊，用到的时候一定注意锁对象的使用范围，例如避免计算hashcode等。

两个参数： -XX:BiasedLockingStartupDelay=0，-XX:-(+)UseBiasedLocking


* 还有一个TypeClass NameOps，但是是一个内部类，有一个$outer外部类引用。